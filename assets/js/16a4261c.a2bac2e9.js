"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[721],{4290:function(e,t,n){n.r(t),n.d(t,{frontMatter:function(){return s},contentTitle:function(){return l},metadata:function(){return p},toc:function(){return c},default:function(){return m}});var a=n(7896),r=n(1461),i=(n(2784),n(876)),o=["components"],s={sidebar_position:1},l="Motivation",p={unversionedId:"introduction/motivation",id:"introduction/motivation",isDocsHomePage:!1,title:"Motivation",description:"Text Localizer is a package born out of the need to manage translations in a typesafe manner.",source:"@site/docs/introduction/motivation.md",sourceDirName:"introduction",slug:"/introduction/motivation",permalink:"/text-localizer/docs/introduction/motivation",editUrl:"https://github.com/facebook/docusaurus/edit/main/website/docs/introduction/motivation.md",tags:[],version:"current",sidebarPosition:1,frontMatter:{sidebar_position:1},sidebar:"tutorialSidebar",next:{title:"Installation",permalink:"/text-localizer/docs/introduction/installation"}},c=[{value:"Lightweight",id:"lightweight",children:[]},{value:"Fast",id:"fast",children:[]},{value:"Flexible",id:"flexible",children:[]}],u={toc:c};function m(e){var t=e.components,n=(0,r.Z)(e,o);return(0,i.kt)("wrapper",(0,a.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"motivation"},"Motivation"),(0,i.kt)("p",null,"Text Localizer is a package born out of the need to manage translations in a typesafe manner.\nCurrently, the best-known solutions in javascript for managing translations are based on a key-value approach (",(0,i.kt)("a",{parentName:"p",href:"https://github.com/fnando/i18n-js"},"i18n.js"),", ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/i18next/i18next"},"i18next"),")."),(0,i.kt)("p",null,"This approach involves this way of accessing the individual translation."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"console.log(translationsObject.get('translations_key'));\n")),(0,i.kt)("p",null,"The main problems with this approach are that:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("em",{parentName:"li"},"There is no effective compile-time support to catch errors if the key is wrong;")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("em",{parentName:"li"},"There is no way of knowing whether the key being accessed is set for all languages;")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("em",{parentName:"li"},"There is no warning if you try to access an unsupported locale;")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("em",{parentName:"li"},"The refactoring of translation keys can easily lead to problems that cannot be intercepted at compile-time."))),(0,i.kt)("p",null,"Consequently, the goal of ",(0,i.kt)("strong",{parentName:"p"},"TextLocalizer")," is to provide a ",(0,i.kt)("strong",{parentName:"p"},"lightweight"),", ",(0,i.kt)("strong",{parentName:"p"},"fast"),", and ",(0,i.kt)("strong",{parentName:"p"},"flexible")," way to access translation strings in a ",(0,i.kt)("strong",{parentName:"p"},"type-safe")," manner in the ",(0,i.kt)("strong",{parentName:"p"},"JavaScript")," world."),(0,i.kt)("h3",{id:"lightweight"},"Lightweight"),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"The package must be easy to use and must not increase the size of the bundle."),"\nFortunately, Text Localizer successfully achieves this by weighing less than ",(0,i.kt)("strong",{parentName:"p"},"2kb")," ",(0,i.kt)("em",{parentName:"p"},"minified")," and less than ",(0,i.kt)("strong",{parentName:"p"},"1kb")," ",(0,i.kt)("em",{parentName:"p"},"gzipped"),"."),(0,i.kt)("h3",{id:"fast"},"Fast"),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"The package must not impact the start-up time in any way."),"\nTo achieve this, Text Localizer extensively supports dynamic imports. This allows translations to be specified in files of type ",(0,i.kt)("strong",{parentName:"p"},"JSON"),", ",(0,i.kt)("strong",{parentName:"p"},"TS")," or ",(0,i.kt)("strong",{parentName:"p"},"JS")," and the translations can be passed into the Text Localizer constructor via dynamic imports."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"const localizer = new TextLocalizer({\n  it: import('./l10n/it.json'),\n  gb: import('./l10n/gb'),\n});\n")),(0,i.kt)("h3",{id:"flexible"},"Flexible"),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"The package must adapt to several use cases without affecting the architecture of the project."),"\nThis requirement is by far the most important one. In order to meet it, Text Localizer allows several modes of operation."),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Inferred Types"),": definitely the most convenient way to use Text Localizer if all translations are available at compile-time. The great advantage of this approach is that in the development phase it is possible to have type-safety of the translations without any extra work."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Generated Types"),": this approach is the most natural one if the strings of translations are only available at runtime. In this case, in the development phase, it will be necessary to run a script which will generate a .d.ts file containing the types of the translation strings.")),(0,i.kt)("p",null,(0,i.kt)("em",{parentName:"p"},"Note"),": Although these are the most natural ways of using Text Localizer, this does not exclude the possibility of using an ",(0,i.kt)("strong",{parentName:"p"},'"Inferred Types"')," approach in the case of translation strings available at run-time, or of using a ",(0,i.kt)("strong",{parentName:"p"},'"Generated Types"')," approach in the case of translation strings available at compile-time."))}m.isMDXComponent=!0},876:function(e,t,n){n.d(t,{Zo:function(){return c},kt:function(){return h}});var a=n(2784);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var l=a.createContext({}),p=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},c=function(e){var t=p(e.components);return a.createElement(l.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,i=e.originalType,l=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),m=p(n),h=r,f=m["".concat(l,".").concat(h)]||m[h]||u[h]||i;return n?a.createElement(f,o(o({ref:t},c),{},{components:n})):a.createElement(f,o({ref:t},c))}));function h(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=n.length,o=new Array(i);o[0]=m;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:r,o[1]=s;for(var p=2;p<i;p++)o[p]=n[p];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}m.displayName="MDXCreateElement"}}]);